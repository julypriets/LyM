/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(Proyecto1)package uniandes.teolen.parserJavaCC.Proyecto1;
import java.util.*;
public class Proyecto1{	ArrayList < String > variables = new ArrayList<String>();
	ArrayList < String > sitios = new ArrayList<String>();
	ArrayList < String > transiciones = new ArrayList<String>();}PARSER_END(Proyecto1)SKIP :{  //" " "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{ < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < DOS_PUNTOS : ":" >
| < IGUAL : " = " >
|< COMA : "," >
| < AP : "(" >
| < CP : ")" >

}TOKEN :{ < num : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < #LETRAMAY : [ "A"-"Z" ] >
| < #LETRAMIN : [ "a"-"z" ] >
| < #LETRA : < LETRAMIN > | < LETRAMAY > >
| < nombre : < LETRA > (< LETRA > | < num >)+ >
| < UNIFORME : "Uniforme" >
| < EXPONENCIAL : "Exponencial" >
| < DETERMINISTICO : "Deterministico" >
| < CAPACIDAD : "capacidad" >
| < MARCACION : "marcacion_i" >
| < holi : "holi" >
| < P_RED : "P_RED" >
| < VAR:  "VAR" >
| < VARIABLE: (< LETRA >)* | < num > >
| < SITIO : "SITIO" >
| < TRANSICION : "TRANSICION" >
| < ARCO : "ARCO" >
| < FIN_RED : "FIN_RED" >
}

void pRed():
{
  
}
{
  < P_RED ><nombre > (var())+ (sitio())+ (transicion())+ (arco())+ < FIN_RED >
}

void var(): 
{Token t1;}
{
 < VAR >(t1 = <nombre >)
 {
   boolean encontrado = false; 
   for(int i = 0; i<variables.size() && !encontrado; i++) {
     if(variables.get(i).equals(t1.image)) {
       encontrado = true; 
   }
   if(encontrado) { throw new Error("La variable ya se encontraba declarada previamente :c"); }
   else {  variables.add(t1.image); }
   }
}
 <IGUAL ><num >
}


void sitio():
{Token t1; Token v; String variable;}
{
  <SITIO ><DOS_PUNTOS > (t1= < nombre >)
 {
   boolean encontrado = false; 
   for(int i = 0; i<sitios.size() && !encontrado; i++) {
     if(sitios.get(i).equals(t1.image)) {
       encontrado = true; 
   }
   if(encontrado) { throw new Error("El sitio ya se encontraba declarada previamente :c"); }
   else { sitios.add(t1.image); }
   }
}
 <CAPACIDAD ><DOS_PUNTOS ><IGUAL >(< num >| (v = < nombre >)

{
  if(variables.get(v.image)==null) {
    throw new Error ("La variable dada no existe"); 
  } else { variable = v.image; }
}
)<MARCACION ><DOS_PUNTOS ><IGUAL >(<num >|< CAPACIDAD >) 
}


void transicion():
{Token t; Token t1;}
{
 < TRANSICION >((t = < nombre >
 {
    //Solo crea transiciones si no existen antes. 
   boolean encontrado = false; 
   for(int i = 0; i<transiciones.size() && !encontrado; i++) {
     if(transiciones.get(i).equals(t.image)) {
       encontrado = true; 
   }
   if(encontrado) { throw new Error("La transicion ya se encontraba declarada previamente :c"); }
   else { transiciones.add(t.image); }
   }  
 })|(< TRANSICION ><AP >(t1 = < nombre >
 {
   //Solo crea transiciones si no existen antes. 
   boolean encontrado = false; 
   for(int i = 0; i<transiciones.size() && !encontrado; i++) {
     if(transiciones.get(i).equals(t1.image)) {
       encontrado = true; 
   }
   if(encontrado) { throw new Error("La transicion ya se encontraba declarada previamente :c"); }
   else { transiciones.add(t1.image); }
   }  
 })<COMA >(< EXPONENCIAL ><COMA > dobleParametro() |<DETERMINISTICO ><COMA >parametro()|<UNIFORME ><COMA >dobleParametro())<CP >))
}

void dobleParametro():
{}
{
  parametro() < COMA > parametro()
}

void parametro():
{}
{
  (< num >|verificarVar())|fact()
}
void arco():
{}
{
< ARCO ><AP ><holi ><COMA ><holi ><COMA ><holi ><CP >
}

void verificarVar():
{Token t;}
{
	(t = < nombre >)
{
    //Si la variable no existe, sale un error
  boolean encontrado = false; 
   for(int i = 0; i<variables.size() && !encontrado; i++) {
     if(variables.get(i).equals(t2.image)) {
       encontrado = true; 
   }
   if(!encontrado) { throw new Error("La variable no existe :'v"); }
   }
}
}


void exp() :
{}
{
// Parses  E -> E + T
//         E -> E - T
//         E -> T
//   in EBNF:  E -> T {+ T   | - T }
  
 term() ( < PLUS > term() | < MINUS > term() )*
}

void term() :
{}
{
// Parses  T -> T * F
//         T -> T / F
//         T -> F
//   in EBNF:  T -> F {* F   | /  F }
  
 fact() ( < MULTIPLY > fact() | < DIVIDE > fact() )*
}

void fact() :
{
// Parses  F -> B
//         F -> -B
//         B -> num
//         B -> '(' E ')'
//   in EBNF:  F -> [-](num |'(' E ')')
}
{
    (< MINUS >)? ((< num >|var()) "(" exp() ")")
}

//No se hacen excepciones sino es error.
//t.image accede directamente al atributo del token. 