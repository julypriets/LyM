/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{
  IGNORE_CASE = false;  static = false;}PARSER_BEGIN(Proyecto1)package uniandes.teolen.parserJavaCC.Proyecto1;
import java.util.*;
public class Proyecto1{	ArrayList < String > variables = new ArrayList<String>();
	ArrayList < String > sitios = new ArrayList<String>();
	ArrayList < String > transiciones = new ArrayList<String>();}PARSER_END(Proyecto1)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{ < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < DOS_PUNTOS : ":" >
| < IGUAL : "=" >
|< COMA : "," >
| < AP : "(" >
| < CP : ")" >
}TOKEN :{ < num : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < #LETRAMAY : [ "A"-"Z" ] >
| < #LETRAMIN : [ "a"-"z" ] >
| < #LETRA : < LETRAMIN > | < LETRAMAY > >
| < VAR:  "VAR" >
| < UNIFORME : "Uniforme" >
| < EXPONENCIAL : "Exponencial" >
| < DETERMINISTICO : "Deterministico" >
| < CAPACIDAD : "capacidad" >
| < MARCACION : "marcacion_i" >
| < ENTRANDO : "Entrando:" >
| < holi : "holi" >
| < ARCO : "ARCO" >
| < TRANSICION : "TRANSICION" >
| < SITIO : "SITIO" >
| < nombre : < LETRA > (< LETRA > | < num >)+ >
| < P_RED : "P_RED" >
| < FIN_RED : "FIN_RED" >
}

void pRed():
{
  
}
{
  < P_RED ><nombre > (var())+ (sitio())+ (transicion())+ (arco())+ < FIN_RED >
}

void var(): 
{Token t1;}
{
 < VAR > (t1=<nombre >)
{
   boolean encontrado = false; 
   for(int i = 0; i<variables.size() && !encontrado; i++) {
     if(variables.get(i).equals(t1.image)) {
       encontrado = true; 
   }
   if(encontrado) { throw new Error("La variable ya se encontraba declarada previamente :c"); }
   else {  variables.add(t1.image); }
   }
}

 (<IGUAL >)(<num >)
}


void sitio():
{Token t1; Token v; String variable;}
{
  <SITIO ><DOS_PUNTOS > (t1= < nombre >)
 {
   boolean encontrado = false; 
   for(int i = 0; i<sitios.size() && !encontrado; i++) {
     if(sitios.get(i).equals(t1.image)) {
       encontrado = true; 
   }
   if(encontrado) { throw new Error("El sitio ya se encontraba declarada previamente :c"); }
   else { sitios.add(t1.image); }
   }
}
 <CAPACIDAD ><DOS_PUNTOS ><IGUAL >(< num >| ((verificarVar())((< PLUS >|< MINUS >|< MULTIPLY >|< DIVIDE >)(verificarVar()))?)


)<MARCACION ><DOS_PUNTOS ><IGUAL >(<num >|< CAPACIDAD >) 
}


void transicion():
{Token t; Token t1;}
{
 < TRANSICION >((t = < nombre >
 {
    //Solo crea transiciones si no existen antes. 
   boolean encontrado1 = false; 
   for(int i = 0; i<transiciones.size() && !encontrado1; i++) {
     if(transiciones.get(i).equals(t.image)) {
       encontrado1 = true; 
   }
   if(encontrado1) { throw new Error("La transicion ya se encontraba declarada previamente :c"); }
   else { transiciones.add(t.image); }
   }  
 })|(< TRANSICION ><AP >(t1 = < nombre >
 {
   //Solo crea transiciones si no existen antes. 
   boolean encontrado = false; 
   for(int i = 0; i<transiciones.size() && !encontrado; i++) {
     if(transiciones.get(i).equals(t1.image)) {
       encontrado = true; 
   }
   if(encontrado) { throw new Error("La transicion ya se encontraba declarada previamente :c"); }
   else { transiciones.add(t1.image); }
   }  
 })<COMA >(< EXPONENCIAL ><COMA > dobleParametro() |<DETERMINISTICO ><COMA >parametro()|<UNIFORME ><COMA >dobleParametro())<CP >))
}

void dobleParametro():
{}
{
  parametro() < COMA > parametro()
}

void parametro():
{}
{
  (< num >|verificarVar())|fact()
}
void arco():
{}
{
< ARCO ><AP >(arcoEntrando()|arco2())
}

void arcoEntrando():
{Token t1; Token t2; }
{
  < ENTRANDO >
  (t1 = < nombre >)
{
      boolean encontrado1 = false; 
   for(int i = 0; i<transiciones.size() && !encontrado1; i++) {
     if(variables.get(i).equals(t1.image)) {
       encontrado1 = true; 
   }
   if(!encontrado1) { throw new Error("La variable no existe :'v"); }
   }
 }

 < COMA >(t2 = < nombre >)

   {
      boolean encontrado = false; 
   for(int i = 0; i<transiciones.size() && !encontrado; i++) {
     if(variables.get(i).equals(t2.image)) {
       encontrado = true; 
   }
   if(!encontrado) { throw new Error("La variable no existe :'v"); }
   }
 }
}

void arco2():
{Token t1; Token t2;}
{
  (t1 = < nombre >)< COMA >(t2 = < nombre >)(< CP >|(< COMA >(< num >(< PLUS >|< MINUS >|< MULTIPLY >|< DIVIDE >)< nombre >)< CP >))
  {

    int p1=0;
    int p2=0;
    
      boolean encontrado1 = false; 
   for(int i = 0; i<transiciones.size() && !encontrado1; i++) {
     if(transiciones.get(i).equals(t1.image)) {
       encontrado1 = true;
       p1=1; 
   }
   if(!encontrado1) { throw new Error("La variable no existe :'v"); }
   }

   for(int i = 0; i<sitios.size() && !encontrado1; i++) {
     if(sitios.get(i).equals(t1.image)) {
       encontrado1 = true;
       p1=2; 
   }
   if(!encontrado1) { throw new Error("La variable no existe :'v"); }
 }

 boolean encontrado2 = false; 
   for(int i = 0; i<transiciones.size() && !encontrado2; i++) {
     if(transiciones.get(i).equals(t2.image)) {
       encontrado2 = true;
       p2=1; 
   }
   if(!encontrado2) { throw new Error("La variable no existe :'v"); }
   }

   for(int i = 0; i<sitios.size() && !encontrado2; i++) {
     if(sitios.get(i).equals(t2.image)) {
       encontrado2 = true;
       p2=2;
   }
   if(!encontrado2) { throw new Error("La variable no existe :'v"); }
 }

 if(p1==p2)
 {
throw new Error("No puede haber arcos entre dos elementos del mismo tipo.");
 } 
}
}

void verificarVar():
{Token t;}
{
	(t = < nombre >)
{
    //Si la variable no existe, sale un error
  boolean encontrado = false; 
   for(int i = 0; i<variables.size() && !encontrado; i++) {
     if(variables.get(i).equals(t.image)) {
       encontrado = true; 
   }
   if(!encontrado) { throw new Error("La variable no existe :'v"); }
   }
}
}


void exp() :
{}
{
// Parses  E -> E + T
//         E -> E - T
//         E -> T
//   in EBNF:  E -> T {+ T   | - T }
  
 term() ( < PLUS > term() | < MINUS > term() )*
}

void term() :
{}
{
// Parses  T -> T * F
//         T -> T / F
//         T -> F
//   in EBNF:  T -> F {* F   | /  F }
  
 fact() ( < MULTIPLY > fact() | < DIVIDE > fact() )*
}

void fact() :
{
// Parses  F -> B
//         F -> -B
//         B -> num
//         B -> '(' E ')'
//   in EBNF:  F -> [-](num |'(' E ')')
}
{
    (< MINUS >)? ((< num >|verificarVar()) "(" exp() ")")
}

//No se hacen excepciones sino es error.
//t.image accede directamente al atributo del token. 